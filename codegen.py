#!/usr/bin/env python

import itertools
import os
import random
import re
import simplejson as json
import sys
import string

sys.path.append(os.path.join("..","rabbitmq-codegen"))
from amqp_codegen import *

BANNED_CLASSES=['access', 'tx']
BANNED_FIELDS= {
    'ticket': 0,
    'nowait': 0,
    'capabilities': '',
    'insist' : 0,
    'out_of_band': '',
    'known_hosts': '',
}

def pyize(*args):
    a = ' '.join(args).replace('-', '_').replace(' ', '_')
    if a == 'global': a+= '_'
    if a == 'type': a+= '_'
    return a

def Pyize(*args):
    return ''.join([a.title() for a in args]).replace('-', '').replace(' ', '')

def PYIZE(*args):
    return ' '.join(args).replace('-', '_').replace(' ', '_').upper()


def print_constants(spec):
    for c in spec.allClasses():
        for m in c.allMethods():
            print "%-32s= 0x%08X \t# %i,%i %i" % (
                m.u,
                m.method_id,
                m.klass.index, m.index, m.method_id
                )

    print
    for c in spec.allClasses():
        print "%-24s= 0x%04X" % (
            c.u,
            c.index,)
    print



def GetAmqpSpec(spec_path, accepted_by_udate):
    spec = AmqpSpec(spec_path)

    for c in spec.allClasses():
        c.banned = bool(c.name in BANNED_CLASSES)
        c.u = PYIZE('CLASS', c.name)

    spec.classes = filter(lambda c:not c.banned, spec.classes)

    for c in spec.allClasses():
        for m in c.allMethods():
            m.u = PYIZE('METHOD', m.klass.name, m.name)
            m.method_id = m.klass.index << 16 | m.index

            for f in m.arguments:
                f.t = spec.resolveDomain(f.domain)
                f.n = pyize(f.name)
                f.banned = bool(f.name in BANNED_FIELDS)
    return spec

def main(spec_path):
    accepted_by_udate = json.loads(file("amqp-accepted-by-update.json").read())
    spec = GetAmqpSpec(spec_path, accepted_by_udate)
    print """# Autogenerated - do not edit
import struct
from . import table

"""
    print_constants(spec)

    print """
def split_headers(user_headers, properties_set):
    props = {}
    headers = {}
    for key, value in user_headers.iteritems():
        if key in properties_set:
            props[key] = value
        else:
            headers[key] = value
    return props, headers

def encode_body(body, frame_size):
    limit = frame_size - 8 - 1   # spec is broken...
    r = []
    while body:
        payload, body = body[:limit], body[limit:]
        r.append( (0x03, payload) )
    return r
"""

if __name__ == "__main__":
    do_main_dict({"framing": main})







